Передўсторўя.
     Точки це гра в яку часто грають школярў на уроках ў поза  ни-
     ми.Вона вимагаї велико∙ уваги а також високого тактичго  мис-
     лення.Тому вона по праву вўдноситься до навчальних ўгор.

Ўнструкцўя користувача

Цўль гри
     Оточити точки суперника.Спосўб Ви ў ваш
     суперник робите ходи один за одним. За один
     хўд ви можете поставити ОДНУ точку.

Дивўться
     x - Точки вашого суперника
     + - Вашў точки

           +         +-+-+-+-+
          / \       /    |    \
         + x + або + x x + x x +
          \ /       \   / \    |
           +         +-+   +-+-+

     За один хўд ви можете оточити одну або бўльше
     точок. Якщо в кўнцў гри Ваш рахунок най-
     бўльший то Ви ПЕРЕМОЖЕЦЬ

Увага:
     Hе можна ставити точки в уже зроблене оточен-
     ня або переходжувати. Поржнї мўсце не оточу-
     їться.Якщо Ви походили в порожнї оточення,то
     спочатку перевўряїться чи не можете оточити
     Ви,якщо можете то оточуйте ўнакше буде отчено
     Вас.


Формат конфўгурацўйного файлу Points.cfg

[Y/N] -Знищувати внутрўшнў лўнў∙ чи нў
*.Cur -Ўм'я файла з курсором мишў для гри
*.Cur -Ўм'я файла з курсором мишў для настройок
*     -Ўм'я мережевого диска







Проблеми що виникали в процесў створення гри ў способи ∙х вирўшення.
     1.Органўзацўйнў питання пов'язанў ўз контролем за додержанням правил гри
       гравцями.(Швидка перевўрка можливостў оточення та саме оточення)

     2.Ввўд ўнформацў∙ з клавўатури в графўчному режимў.
       Емуляцўя клавўатури та використання "мишў".
       Вивўд ўнформацў∙ в графўчних вўкнах.

     3.Запис в пам'ять зображення бўльшого нўж 64 Кб.



    У вирўшеннў всўх питаннь застосовувалась технологўя ООП.У вирўшеннў питання
"1" також використано нововведення  фўрми  Borland для Turbo Pascal 7.0 так
званий процедурний тип даних (коли параметром для одно∙ процедури ї ўм'я ўншо∙
тип яко∙ оголошено попередньо).




Питання 1
     По перше всў масиви типу TFild мають наступну структуру
                  v
      ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───
      │   │   │   │   │   │   │   │   │   │   │
      ├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┼───
      │   │███│   │███│   │███│   │███│   │███│
      ├───┼───├───┼───┼───┼───┼───┼───┼───┼───┼───
      │   │   │   │   │   │   │   │   │   │   │
     >├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┼───
      │   │███│   │███│   │███│   │███│   │███│
      ├───┼───├───┼───┼───┼───┼───┼───┼───┼───┼───
      │   │   │   │   │   │   │   │   │   │   │
      ├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┼───
      │   │███│   │███│   │███│   │███│   │███│


     Крайнў три рядки з кожного боку не використовуються,це  зроб-
лено для спрощення алгоритму оточення.

     ████ - мўсце для запису точки(записуїться номер гравця)
    ┌────┐
    │    │- мўсце для запису лўнўй що з'їднують точки
    └────┘

Алгоритм  оточення
       1.Пўдготувати масив Work
                     A)Скопўювати масив Original в  масив  Work
                     Б)Знищити  в  масивў  Work  всў лўнў∙ оточення
       2.Перевўрити чи можливе   оточення
Примўтка:
          У  змўнних  XPot  ў  YPot  на  початку  роботи  функцўй зберўгаються
          координати  останньо∙  поставлено∙  точки.Очевидно, що вона буде
          початком  контуру  оточення  (  контур  оточення  -  точки якў беруть
          участь в оточеннў ) ,отже перевўрка починаїться з дано∙ точки чим ў
          забезпечено ∙∙ швидкодўю.Перевўрку  можливостў оточення здўснюї
          пара рекурсивних функўй VRound_1 ў Connect,запускаїться ж перевўрка
          можливостў оточення викликом функцў∙ VRound яка зберўгаї значення
          змўнних XPot ў YPot оскўльки функцў∙ VRound_1 ў Connect в процесў
          роботи змўнюють значення цих змўнних.Функцў∙ VRound_1 та Connect
          видўленў в окремў модулў тому що для програми або модуля пўд стек
          видўляїться всього 64 Кб пам'ятў чого для перевўрки можливостў
          оточення при великому контурў оточення може виявитись недостатньо.
          Параметрами VRound_1 та Connect ї вектори напрямку перевўрки
          (1,0-праворуч, 0,-1-вниз, 1,1-вгору ў праворуч, ў т.д.).
          Для зв'язку ўнших модулўв з основною  програмою створено модуль
          ForPoint в який помўщено  всў  основнў  константи,типи ў глобальнў
          змўннў.
           ( VRound_1 )
            А)Поки вектор напрямку не опише коло робити
                   (Сonnect)
                   А1)Connect:=False
                   Б1)Якщо на даному напрямку ї своя точка яка не з'їднана ў
                      не вўдокремлена лўнўями тодў:
                        а) сполучити ∙∙
                        б) перемўстити вказўвник XPot YPot на дану точку
                        в)викликати VRound_1 з вектором що вказуватиме на
                          попередню точку
                        г)якщо VRound_1=True тодў ў Connect:=True
                   (Кўнець Connect)
                   В1)Якщо Connect=True то ви хўд з циклу
            Б)Якщо кўлькўсть лўнўй якими з'їднана точка менше двох зробити
              крок назад(тобто знищити дану точку ў перемўститись на попередню)
            В)Якщо кўлькўсть лўнўй якими з'їднана точка не дорўвнюї двом тодў
              VRound_1:=False.

    Цей алгоритм перевўряї чи можливе оточення починаючи з заданого напрямку.
Вўн знаходить оточення,але не обов'язково максимальне (максимальне оточення
отримаїмо тодў коли початковий напрямок перевўрки буде поза майбутнўм
оточенням).Тодў як алгоритму для обробки оточено∙ частини масиву необхўдно щоб
оточення було максимальним.Отже основна пўдпрограма для знаходження максимально-
го оточення працюї наступним чином.

            А)Здўйснюї оточення для кожного напрямку ў знаходить
              максимальне.
            Б)Якщо оточення не здўйснене то вихўд з пўдпрограми з сигналом про
              неможливўсть оточення.
            В)Якщо кўлькўсть оточених точок дорўвнюї нулю то координати оточених
              порожнўх мўсць заносяться в стек (WorkSubStack),координати початку
              оточення ў WorkSubStack заносяться у ўнший стек(WorkStack),а самў
              оточенў порожнў мўсця маркуються спецўальним символом(EmergyPlase)

            Г)Якщо ж кўлькўсть оточених точок не дорўвнюї нулю то:
                   а)всў порожнў оточенў мўсця маркуються спецўальним
                   символом(RoundedEmptyPlase),При пўдрахунку очок цей символ
                   приймаїться як порожнї мўсце,а при здўйсненнў ходу,як зайняте
                   точкою.
                   б)оточена область копўюїться в оригўнальний масив(Original)
            Д)Вихўд з пўдпрограми з сигналом про здўйснене оточення
         3.Якщо оточення здўйснене то вўдобразити його графўчно також пўдрахувати очки
           гравцўв ў вивести ∙х на екран

            1.Погасити верхнўй ў нижнўй "лўхтарики"
            2.Цикл по парним рядкам починаючи з 4

        \ | /      А)Якщо зверху точка з'їднана непарною кўлькўстю лўнўй то
          x          свўтимўсть верхнього "лўхтарика" помўняти на протилежну

          x        Б)Якщо знизу точка з'їднана непарною кўлькўстю лўнўй то
        / | \        свўтимўсть нижнього "лўхтарика" помўняти на протилежну

                   В)Якщо обидва лўхтарика свўтяться запустити процедуру оброб-
                     ки даних в оточеннў (наприклад процедуру пўдрахунку очок)




Питання 2
    Для зручностў реїстрацў∙ гравцўв та бўльшо∙ зручностў гри було створено
набўр об'їктўв та пўдпрограм що реалўзують дўаоговий режим роботи.

Об'їкт TMessageBox - реалўзуї вивўд ўнформацў∙ в графўчних вўкнах

Об'їкт TKeyBoard - реалўзуї графўчну емуляцўю клавўатури та використання ∙∙ за
                   допомогою "мишў".В об'їктў TKeyBoard використано стек
                   об'їктўв TButton якў власне ў вўдповўдають за прив'язку
                   клавўшў до вўдповўдно∙ ∙й процедури.Фрагмент екрана
                   прив'язуїться до клавўшў процедурою PutMouseItem(Модуль
                   F_Mouse автор Фаронов.В.В.).Стек реалўзовано обїктом
                   TStackOfButtons який ї потомком об'їкта TStack.
                   Ось структура даних об'їкту TStack

                     ┌──────────────────────────────────────────────┐
                     │                                              │
                     │ Info:Pinter{Вказўвник на данў}               ├──>
                     │                                              │
                     ├──────────────────────────────────────────────┤
                     │                                              │
                     │ Next:Pointer{Вказўвник на наступний елемент} │
                     │                                              │
                     └──────────────────┬───────────────────────────┘
                                        │
                                        V

Об'їкт TInputBox - реаўзуї ввўд символўв з клавўатури в графўчному режимў.
                   (Стандартна процедура вводу Read/ReadLn ї дещо незручною
                   для використання в графўчному режимў оскўльки для даного
                   режиму в нўй не забезпечено вўдображення курсора)


    Редагування вказўвника мишў здўйснено редактором Mouse Editor v1.0 (ME.EXE)
написаного мною.Вказўвник зверўгаїться в побайтовому форматў в файлў з
розширенням .cur та в текстовому форматў в файлах з розширенням .txt для
десятково∙ системи числення та з розширенням .hex для шўснадцятково∙
(текстовий формат введено для можливостў "вживлення" образу вказўвника мишў в
програму).
    Графўчний вказўвник мишў задаїться у видў 64 байтного масива який
трактуїться наступним чином.Першў 16 двобайтних слўв це матриця 16 х 16 бўт,
кожен бўт яко∙ маскуї пўксел екрана (це ї маска екрана),наступна матриця
16 х 16 бўт маскуї зображення вказўвника(маска зображення).При створеннў
зображення драйвер отримуї ўнформацўю про 16 х 16 пўксел вўдповўдного мўсця на
екранў ў до кожного пўксела примўняї операцўю AND з маскою екрана,а потўм до
отриманого результату операцўю XOR з маскою зображення.

     ┌─────────────────┬────────────────┬───────────────────────┐
     │  Вид пўксела    │  маска екрану  │   маска зображення    │
     ├─────────────────┼────────────────┼───────────────────────┤
     │   Бўлий         │       0        │          1            │
     │   Чорний        │       0        │          0            │
     │   Нормальний    │       1        │          0            │
     │   Ўнверсований  │       1        │          1            │
     └─────────────────┴────────────────┴───────────────────────┘


Питання 3
        Це питання виникло тому,що часто виникаї потреба швидко приховати той
факт що ви граїте.Сама процедура приховування дуже проста.

    1.В пам'ять записуїться образ екрану(близько 200Кб).
    2.Їкран переводиться в текстовий режим.
    3.Якщо в каталозў з якого ви запускали гру знаходиться файл points2.img ,
      то на екран будуть виведенў панелў Volcov Commander ўнакше екран
      залишиться чорним.
    4.При натисканнў клавўшў "Esc" виконання програми буде завершено.
    5.При натисканнў будь яко∙ ўншо∙ клавўшў графўчний екран вўдновиться ў гру
      буде продовжено.

        А тепер докладнўше про сам спосўб збереження ў вўдновлення зображення.
Нехай зображення задано координатами лўвого верхнього та правого нижнього кутўв
прямокутника (X1,Y1) та (X2,Y2) вўдповўдно.
        Все зображення дўлиться на фрагменти розмўром 10х(X2-X1) пўксел (не
бўльше 2Кб).Кожна частинка записуїться у стек у видў запису(Формат даних в
стеку описаний вище).

        ┌─────────┬───────────┬───────────────┐
        │ DY:Word │  Size:Word│ Image:Pointer │
        └─────────┴───────────┴───────────────┘
        Де
           DY-вўдстань вўд лўвого верхнього кута зображення до лўвого
           верхнього кута фрагмету
           Size-розмўр фрагменту в пам'ятў
           Image-вказўвник на фрагмент




Плани на майбутнї
     В версў∙ 3.0 збираюсь ввести можливўсть гри  проти  комп'юте-
ра,дўалогову змўну конфўгурацў∙,можливисть гри по мережў.

